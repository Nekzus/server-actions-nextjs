name: Cleanup Old Workflow Runs

on:
  schedule:
    - cron: '0 0 * * 0' # Se ejecuta semanalmente los domingos a las 00:00 UTC
  workflow_dispatch: # Permite ejecutarlo manualmente desde la interfaz de GitHub

jobs:
  cleanup:
    runs-on: ubuntu-latest

    steps:
      - name: Set up GitHub CLI and jq
        run: |
          sudo apt-get install -y gh jq

      - name: Delete old workflow runs
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # Usa el GITHUB_TOKEN directamente
          DAYS_TO_KEEP: 30 # Cambia el número de días según sea necesario
          PER_PAGE: 100    # Número de ejecuciones por página (máximo 100)
          MAX_DELETIONS: 50 # Número máximo de ejecuciones a eliminar por ciclo
        run: |
          # Obtener la fecha de límite en formato ISO 8601
          DELETE_BEFORE_DATE=$(date -d "$DAYS_TO_KEEP days ago" --utc +%Y-%m-%dT%H:%M:%SZ)
          
          # Contador de eliminaciones
          DELETED_COUNT=0

          # Obtener todos los workflows del repositorio
          WORKFLOWS=$(gh api graphql -f query='
            query($owner: String!, $repo: String!) {
              repository(owner: $owner, name: $repo) {
                workflows(first: 100) {
                  nodes {
                    id
                    name
                  }
                }
              }
            }
          ' -F owner="${{ github.repository_owner }}" -F repo="${{ github.event.repository.name }}" --jq '.data.repository.workflows.nodes[].id')

          # Iterar sobre cada workflow y eliminar ejecuciones antiguas
          for workflow_id in $WORKFLOWS; do
            # Manejo de paginación manual
            NEXT_CURSOR="null"
            
            while true; do
              # Obtener lista de ejecuciones completadas y antiguas en una sola llamada
              RUNS=$(gh api graphql -f query='
                query($workflowId: ID!, $limit: Int!, $cursor: String) {
                  node(id: $workflowId) {
                    ... on Workflow {
                      runs(first: $limit, after: $cursor, statuses: COMPLETED) {
                        edges {
                          node {
                            id
                            createdAt
                          }
                          cursor
                        }
                      }
                    }
                  }
                }
              ' -F workflowId="${workflow_id}" -F cursor="${NEXT_CURSOR}" -F limit="${PER_PAGE}" --jq '.data.node.runs.edges | map(select(.node.createdAt < "'$DELETE_BEFORE_DATE'")) | .[] | .node.id + "," + .cursor')

              # Si no hay más ejecuciones, salir del bucle
              if [ -z "$RUNS" ]; then
                echo "No more old workflow runs to delete for workflow ID: $workflow_id."
                break
              fi

              # Iterar sobre cada ejecución y eliminarla
              while IFS=, read -r run_id cursor; do
                echo "Deleting workflow run with ID: $run_id"
                gh run delete "$run_id" -y || continue
                DELETED_COUNT=$((DELETED_COUNT+1))

                # Esperar un segundo entre eliminaciones para no sobrecargar la API
                sleep 1

                # Si alcanzamos el número máximo de eliminaciones, salir del bucle
                if [ $DELETED_COUNT -ge $MAX_DELETIONS ]; then
                  echo "Reached maximum deletions for this run: $MAX_DELETIONS"
                  break 2
                fi

                # Actualizar el cursor para la siguiente paginación
                NEXT_CURSOR=$cursor
              done <<< "$RUNS"
            done
          done

          echo "Total workflow runs deleted: $DELETED_COUNT"
